//! iOS Package and Application Management
//! 
//! This module handles iOS package detection and management for both
//! simulators and physical devices.

use super::super::types::{DeviceResponse, Package};
use super::tools::get_tool_command_legacy;
use super::diagnostic::get_ios_error_help;
use tauri_plugin_shell::ShellExt;
use crate::commands::device::ios::tool_validation::find_ios_tool;
use crate::commands::device::ios::windows_dependencies::diagnose_ideviceinstaller_issue;
use log::{info, warn, error};
use serde_json::Value;
use std::process::Command;
use tauri::command;

/// Get list of iOS packages (for simulators)
#[tauri::command]
pub async fn device_get_ios_packages(app_handle: tauri::AppHandle, device_id: String) -> Result<DeviceResponse<Vec<Package>>, String> {
    info!("=== GET iOS PACKAGES STARTED (SIMULATOR) ===");
    info!("Device ID (Simulator): {}", device_id);
    
    info!("Step 1: Using xcrun simctl to get installed apps");
    let shell = app_handle.shell();
    
    let output = shell.command("xcrun")
        .args(["simctl", "listapps", &device_id])
        .output()
        .await
        .map_err(|e| format!("Failed to execute xcrun simctl listapps: {}", e))?;
    
    info!("xcrun simctl listapps exit status: {:?}", output.status);
    
    if !output.status.success() {
        let error_msg = String::from_utf8_lossy(&output.stderr);
        error!("‚ùå xcrun simctl listapps command failed: {}", error_msg);
        return Ok(DeviceResponse {
            success: false,
            data: None,
            error: Some(error_msg.to_string()),
        });
    }
    
    info!("Step 2: Parsing simulator apps output");
    let apps_output = String::from_utf8_lossy(&output.stdout);
    let mut packages = Vec::new();
    
    // Log the raw output for debugging
    info!("Raw simctl output (first 200 chars): {}", 
          if apps_output.len() > 200 { &apps_output[..200] } else { &apps_output });
    
    // Parse plist-like output from simctl listapps
    // Format: "bundle.id" = { key = value; ... };
    let mut current_bundle_id: Option<String> = None;
    let mut current_display_name: Option<String> = None;
    let mut current_bundle_name: Option<String> = None;
    
    for line in apps_output.lines() {
        let line = line.trim();
        
        // Look for bundle ID line: "com.example.app" = {
        if line.contains(" = ") && line.ends_with(" {") {
            // Save previous app if we have complete info
            if let Some(bundle_id) = current_bundle_id.take() {
                let app_name = current_display_name.clone()
                    .or(current_bundle_name.clone())
                    .unwrap_or_else(|| bundle_id.clone());
                
                // Clean the bundle ID and app name in case they have trailing commas or whitespace
                let clean_bundle_id = bundle_id.trim().trim_end_matches(',').to_string();
                let clean_app_name = app_name.trim().trim_end_matches(',').to_string();
                
                if clean_bundle_id != bundle_id || clean_app_name != app_name {
                    info!("üßπ Cleaned simulator package: '{}' -> '{}', name: '{}' -> '{}'", 
                          bundle_id, clean_bundle_id, app_name, clean_app_name);
                }
                
                let package = Package {
                    name: clean_app_name.clone(),
                    bundle_id: clean_bundle_id.clone(),
                };
                
                info!("Found app: {} ({})", package.name, package.bundle_id);
                packages.push(package);
            }
            
            // Extract new bundle ID
            if let Some(equals_pos) = line.find(" = ") {
                let bundle_part = &line[..equals_pos];
                // Remove quotes if present
                let bundle_id = bundle_part.trim_matches('"').trim_matches('\'');
                
                // Filter out system directories that aren't actual apps
                if bundle_id == "GroupContainers" || 
                   bundle_id == "SystemContainers" || 
                   bundle_id == "SharedContainers" ||
                   bundle_id == "Containers" ||
                   !bundle_id.contains('.') { // Bundle IDs should contain dots (reverse domain notation)
                    info!("Skipping system directory: {}", bundle_id);
                    current_bundle_id = None;
                    current_display_name = None;
                    current_bundle_name = None;
                } else {
                    current_bundle_id = Some(bundle_id.to_string());
                    current_display_name = None;
                    current_bundle_name = None;
                }
            }
        }
        // Look for CFBundleDisplayName
        else if line.contains("CFBundleDisplayName = ") {
            if let Some(equals_pos) = line.find(" = ") {
                let value_part = &line[equals_pos + 3..];
                let value = value_part.trim_end_matches(';').trim_matches('"').trim_matches('\'');
                current_display_name = Some(value.to_string());
            }
        }
        // Look for CFBundleName as fallback
        else if line.contains("CFBundleName = ") && current_display_name.is_none() {
            if let Some(equals_pos) = line.find(" = ") {
                let value_part = &line[equals_pos + 3..];
                let value = value_part.trim_end_matches(';').trim_matches('"').trim_matches('\'');
                current_bundle_name = Some(value.to_string());
            }
        }
    }
    
    // Don't forget the last app
    if let Some(bundle_id) = current_bundle_id {
        // Filter out system directories that aren't actual apps
        if bundle_id == "GroupContainers" || 
           bundle_id == "SystemContainers" || 
           bundle_id == "SharedContainers" ||
           bundle_id == "Containers" ||
           !bundle_id.contains('.') { // Bundle IDs should contain dots (reverse domain notation)
            info!("Skipping system directory in final check: {}", bundle_id);
        } else {
            let app_name = current_display_name
                .or(current_bundle_name)
                .unwrap_or_else(|| bundle_id.clone());
            
            // Clean the bundle ID and app name in case they have trailing commas or whitespace
            let clean_bundle_id = bundle_id.trim().trim_end_matches(',').to_string();
            let clean_app_name = app_name.trim().trim_end_matches(',').to_string();
            
            if clean_bundle_id != bundle_id || clean_app_name != app_name {
                info!("üßπ Cleaned last simulator package: '{}' -> '{}', name: '{}' -> '{}'", 
                      bundle_id, clean_bundle_id, app_name, clean_app_name);
            }
            
            let package = Package {
                name: clean_app_name.clone(),
                bundle_id: clean_bundle_id.clone(),
            };
            
            info!("Found app: {} ({})", package.name, package.bundle_id);
            packages.push(package);
        }
    }
    
    info!("=== GET iOS PACKAGES COMPLETED ===");
    info!("Found {} packages on simulator", packages.len());
    
    Ok(DeviceResponse {
        success: true,
        data: Some(packages),
        error: None,
    })
}

/// Get list of iOS packages from physical device
#[tauri::command]
pub async fn device_get_ios_device_packages(app_handle: tauri::AppHandle, device_id: String) -> Result<DeviceResponse<Vec<Package>>, String> {
    info!("=== GET iOS DEVICE PACKAGES STARTED ===");
    info!("Device ID: {}", device_id);
    
    let shell = app_handle.shell();
    let ideviceinstaller_cmd = get_tool_command_legacy("ideviceinstaller");
    info!("Using ideviceinstaller command: {}", ideviceinstaller_cmd);
    
    // First try XML mode for faster parsing
    info!("Step 1: Trying XML mode for faster parsing");
    let xml_output = shell.command(&ideviceinstaller_cmd)
        .args(["-u", &device_id, "-l", "-o", "xml"])
        .output()
        .await
        .map_err(|e| format!("Failed to execute ideviceinstaller: {}", e))?;
    
    info!("ideviceinstaller XML exit status: {:?}", xml_output.status);
    
    // Handle Windows-specific DLL dependency issues for ideviceinstaller
    let is_xml_success = if cfg!(target_os = "windows") {
        match xml_output.status.code() {
            Some(-1073741701) => {
                // This specific exit code indicates DLL dependency issues
                // Log this but don't treat it as a complete failure - try fallback
                error!("‚ö†Ô∏è ideviceinstaller has DLL dependency issues (exit code -1073741701). This may indicate missing Visual C++ Redistributable or other Windows dependencies.");
                false
            },
            Some(0) => true,
            _ => xml_output.status.success(),
        }
    } else {
        xml_output.status.success()
    };
    
    if is_xml_success {
        let xml_content = String::from_utf8_lossy(&xml_output.stdout);
        info!("üì± XML output received, length: {} characters", xml_content.len());
        
        // Try XML parsing first
        match parse_ios_apps_xml(&xml_content) {
            Ok(packages) if !packages.is_empty() => {
                info!("=== GET iOS DEVICE PACKAGES COMPLETED (XML MODE) ===");
                info!("Found {} packages on device", packages.len());
                return Ok(DeviceResponse {
                    success: true,
                    data: Some(packages),
                    error: None,
                });
            },
            Ok(_) => {
                info!("‚ö†Ô∏è  XML parsing returned 0 packages, trying fallback to regular mode");
            },
            Err(e) => {
                info!("‚ö†Ô∏è  XML parsing failed: {}, trying fallback to regular mode", e);
            }
        }
    } else {
        let error_msg = String::from_utf8_lossy(&xml_output.stderr);
        info!("‚ö†Ô∏è  XML mode failed: {}, trying fallback to regular mode", error_msg);
    }
    
    // Fallback to regular text mode
    info!("Step 2: Fallback to regular text parsing mode");
    let output = shell.command(&ideviceinstaller_cmd)
        .args(["-u", &device_id, "-l"])
        .output()
        .await
        .map_err(|e| format!("Failed to execute ideviceinstaller: {}", e))?;
    
    info!("ideviceinstaller regular exit status: {:?}", output.status);
    
    // Handle Windows-specific DLL dependency issues for ideviceinstaller
    let is_regular_success = if cfg!(target_os = "windows") {
        match output.status.code() {
            Some(-1073741701) => {
                // This specific exit code indicates DLL dependency issues
                error!("‚ùå ideviceinstaller has DLL dependency issues (exit code -1073741701)");
                error!("üí° This usually means missing Visual C++ Redistributable packages or libimobiledevice DLL dependencies");
                error!("üí° To fix this issue:");
                error!("   1. Install Microsoft Visual C++ Redistributable (latest version)");
                error!("   2. Ensure all libimobiledevice DLL files are in the same directory as the executable");
                error!("   3. Check that libplist, libusb, and other dependencies are present");
                false
            },
            Some(0) => true,
            _ => output.status.success(),
        }
    } else {
        output.status.success()
    };
    
    if !is_regular_success {
        let error_msg = String::from_utf8_lossy(&output.stderr);
        error!("‚ùå ideviceinstaller command failed: {}", error_msg);
        
        // Provide user-friendly error message for Windows DLL issues
        let user_friendly_error = if cfg!(target_os = "windows") && 
                                     output.status.code() == Some(-1073741701) {
            "iOS app listing failed due to missing Windows dependencies.\n\n\
            This error usually occurs when required Visual C++ Redistributable packages are missing.\n\n\
            To fix this issue:\n\
            1. Download and install Microsoft Visual C++ Redistributable (latest version) from Microsoft's website\n\
            2. Restart Flippio after installation\n\n\
            If the problem persists, you can still access iOS device databases without app listing functionality.".to_string()
        } else {
            get_ios_error_help(&error_msg)
        };
        
        return Ok(DeviceResponse {
            success: false,
            data: None,
            error: Some(user_friendly_error),
        });
    }
    
    info!("Step 3: Parsing regular text output for apps");
    let apps_output = String::from_utf8_lossy(&output.stdout);
    
    info!("üì± Regular output received, length: {} characters", apps_output.len());
    
    // Parse the regular text output
    let packages = parse_ios_apps_text(&apps_output)?;
    
    info!("=== GET iOS DEVICE PACKAGES COMPLETED (REGULAR MODE) ===");
    info!("Found {} packages on device", packages.len());
    
    Ok(DeviceResponse {
        success: true,
        data: Some(packages),
        error: None,
    })
}

/// Parse iOS apps from XML plist output
fn parse_ios_apps_xml(xml_content: &str) -> Result<Vec<Package>, String> {
    let mut packages = Vec::new();
    let lines: Vec<&str> = xml_content.lines().collect();
    let mut i = 0;
    
    info!("üîç Starting XML parsing of {} lines", lines.len());
    
    // Debug: Show first 20 lines to understand structure
    info!("üìã First 20 lines of XML for debugging:");
    for (idx, line) in lines.iter().take(20).enumerate() {
        info!("  Line {}: {}", idx + 1, line.trim());
    }
    
    // Debug: Look for any CFBundleIdentifier occurrences
    let bundle_id_count = lines.iter().filter(|line| line.trim() == "<key>CFBundleIdentifier</key>").count();
    info!("üîç Found {} occurrences of CFBundleIdentifier key", bundle_id_count);
    
    // Also check for alternative patterns
    let dict_count = lines.iter().filter(|line| line.trim() == "<dict>").count();
    let array_count = lines.iter().filter(|line| line.trim() == "<array>").count();
    info!("üîç Found {} <dict> tags and {} <array> tags", dict_count, array_count);
    
    while i < lines.len() {
        let line = lines[i].trim();
        
        // Look for the start of an app entry - we'll look for CFBundleIdentifier
        if line == "<key>CFBundleIdentifier</key>" {
            info!("üéØ Found CFBundleIdentifier at line {}", i + 1);
            if let Some(bundle_id) = extract_next_string_value(&lines, i) {
                info!("  üì± Extracted bundle ID: {}", bundle_id);
                
                // Now look for the display name within the same dictionary
                let mut app_name = bundle_id.clone(); // Fallback to bundle ID
                let mut dict_depth = 1; // We're already inside a dictionary that contains CFBundleIdentifier
                let mut j = i + 1; // Start from the line after CFBundleIdentifier
                
                // Find the end of this dictionary by tracking <dict> and </dict> tags
                while j < lines.len() {
                    let search_line = lines[j].trim();
                    
                    if search_line == "<dict>" {
                        dict_depth += 1;
                    } else if search_line == "</dict>" {
                        dict_depth -= 1;
                        if dict_depth <= 0 {
                            break; // End of this app's dictionary
                        }
                    } else if search_line == "<key>CFBundleDisplayName</key>" {
                        if let Some(display_name) = extract_next_string_value(&lines, j) {
                            app_name = display_name;
                            info!("  üè∑Ô∏è  Found display name: {}", app_name);
                            break;
                        }
                    } else if search_line == "<key>CFBundleName</key>" && app_name == bundle_id {
                        // Only use CFBundleName if we haven't found CFBundleDisplayName
                        if let Some(bundle_name) = extract_next_string_value(&lines, j) {
                            app_name = bundle_name;
                            info!("  üì¶ Found bundle name: {}", app_name);
                            // Continue looking for CFBundleDisplayName which is preferred
                        }
                    } else if search_line == "<key>CFBundleVersion</key>" {
                        if let Some(version) = extract_next_string_value(&lines, j) {
                            info!("  üî¢ Found version: {}", version);
                            // Optionally include version in app name
                            if app_name != bundle_id && !app_name.contains(&version) {
                                app_name = format!("{} ({})", app_name, version);
                            }
                        }
                    }
                    
                    j += 1;
                }
                
                // Clean the values
                let clean_bundle_id = bundle_id.trim().to_string();
                let clean_app_name = app_name.trim().to_string();
                
                info!("üßπ Cleaned package: '{}' -> '{}', name: '{}' -> '{}'", 
                      bundle_id, clean_bundle_id, app_name, clean_app_name);
                
                // Filter out system/invalid entries
                if !clean_bundle_id.is_empty() && 
                   clean_bundle_id.contains('.') && 
                   !clean_bundle_id.starts_with("com.apple.") { // Skip most Apple system apps
                    
                    let package = Package {
                        name: clean_app_name.clone(),
                        bundle_id: clean_bundle_id.clone(),
                    };
                    
                    info!("‚úÖ Found app: {} ({})", package.name, package.bundle_id);
                    packages.push(package);
                } else {
                    info!("‚è≠Ô∏è  Skipped app: {} ({})", clean_app_name, clean_bundle_id);
                }
                
                // Move i to where we left off in the inner loop
                i = j;
            } else {
                info!("‚ùå Failed to extract bundle ID at line {}", i + 1);
            }
        }
        
        i += 1;
    }
    
    info!("üéØ XML parsing completed - extracted {} valid packages", packages.len());
    Ok(packages)
}

/// Parse iOS apps from regular text output
fn parse_ios_apps_text(text_content: &str) -> Result<Vec<Package>, String> {
    let mut packages = Vec::new();
    let lines: Vec<&str> = text_content.lines().collect();
    
    info!("üîç Starting text parsing of {} lines", lines.len());
    
    // Debug: Show first 10 lines to understand structure
    info!("üìã First 10 lines of text for debugging:");
    for (idx, line) in lines.iter().take(10).enumerate() {
        info!("  Line {}: {}", idx + 1, line.trim());
    }
    
    for (line_num, line) in lines.iter().enumerate() {
        let line = line.trim();
        
        // Skip empty lines
        if line.is_empty() {
            continue;
        }
        
        // Look for lines with comma-separated format: bundle.id, "version", "App Name"
        if line.contains(',') && line.contains('"') {
            info!("üîç Processing line {}: '{}'", line_num + 1, line);
            
            // Try to parse the comma-separated format
            if let Some((bundle_id, app_name)) = parse_app_line(line) {
                // Clean the values
                let clean_bundle_id = bundle_id.trim().to_string();
                let clean_app_name = app_name.trim().to_string();
                
                // Filter out system/invalid entries
                if !clean_bundle_id.is_empty() && 
                   clean_bundle_id.contains('.') && 
                   !clean_bundle_id.starts_with("com.apple.") { // Skip most Apple system apps
                    
                    let package = Package {
                        name: clean_app_name.clone(),
                        bundle_id: clean_bundle_id.clone(),
                    };
                    
                    info!("‚úÖ Found app: {} ({})", package.name, package.bundle_id);
                    packages.push(package);
                } else {
                    info!("‚è≠Ô∏è  Skipped app: {} ({})", clean_app_name, clean_bundle_id);
                }
            } else {
                info!("‚ùå Failed to parse line: {}", line);
            }
        }
    }
    
    info!("üéØ Text parsing completed - extracted {} valid packages", packages.len());
    Ok(packages)
}

/// Parse a single app line in format: bundle.id, "version", "App Name"
fn parse_app_line(line: &str) -> Option<(String, String)> {
    // Split by comma and trim
    let parts: Vec<&str> = line.split(',').collect();
    
    if parts.len() >= 3 {
        let bundle_id = parts[0].trim();
        
        // Extract app name from the last quoted part
        let app_name_part = parts[2].trim();
        if let Some(app_name) = extract_quoted_string(app_name_part) {
            // If bundle_id ends with comma, remove it
            let clean_bundle_id = bundle_id.trim_end_matches(',').trim();
            
            info!("  ‚úÖ Parsed with space format: '{}' - '{}'", clean_bundle_id, app_name_part);
            
            // Format app name with version if available
            let version_part = parts[1].trim();
            if let Some(version) = extract_quoted_string(version_part) {
                let formatted_name = format!("{} ({})", app_name, version);
                info!("üîÑ Reformatted app name: '{}' -> '{}'", app_name_part, formatted_name);
                return Some((clean_bundle_id.to_string(), formatted_name));
            } else {
                return Some((clean_bundle_id.to_string(), app_name));
            }
        }
    }
    
    // Try alternative format with space separation
    if let Some(space_pos) = line.find(' ') {
        let bundle_id = &line[..space_pos];
        let rest = &line[space_pos + 1..];
        
        if rest.contains('"') {
            // Try to extract quoted parts
            let quoted_parts: Vec<&str> = rest.split('"').collect();
            if quoted_parts.len() >= 4 {
                let version = quoted_parts[1];
                let app_name = quoted_parts[3];
                
                let clean_bundle_id = bundle_id.trim_end_matches(',').trim();
                let formatted_name = format!("{} ({})", app_name, version);
                
                info!("  ‚úÖ Parsed with space format: '{}' - '\"{}\" \"{}\"'", clean_bundle_id, version, app_name);
                info!("üîÑ Reformatted app name: '\"{}\" \"{}\"' -> '{}'", version, app_name, formatted_name);
                
                return Some((clean_bundle_id.to_string(), formatted_name));
            }
        }
    }
    
    None
}

/// Extract content from a quoted string
fn extract_quoted_string(s: &str) -> Option<String> {
    let trimmed = s.trim();
    if trimmed.starts_with('"') && trimmed.ends_with('"') && trimmed.len() >= 2 {
        Some(trimmed[1..trimmed.len()-1].to_string())
    } else {
        None
    }
}

/// Extract the next <string>value</string> after a given line index
fn extract_next_string_value(lines: &[&str], start_index: usize) -> Option<String> {
    if start_index + 1 >= lines.len() {
        return None;
    }
    
    // Check the next line first
    let next_line = lines[start_index + 1].trim();
    
    // Look for <string>value</string> pattern
    if next_line.starts_with("<string>") && next_line.ends_with("</string>") {
        let start = "<string>".len();
        let end = next_line.len() - "</string>".len();
        if end > start {
            return Some(next_line[start..end].to_string());
        }
    }
    
    // Also check if the string might be split across lines or have different formatting
    // Look for just <string> tag
    if next_line == "<string>" {
        // Value might be on the next line
        if start_index + 2 < lines.len() {
            let value_line = lines[start_index + 2].trim();
            if start_index + 3 < lines.len() && lines[start_index + 3].trim() == "</string>" {
                return Some(value_line.to_string());
            }
        }
    }
    
    // Check if it's all on one line but with extra whitespace
    if let Some(string_start) = next_line.find("<string>") {
        if let Some(string_end) = next_line.find("</string>") {
            let start = string_start + "<string>".len();
            let end = string_end;
            if end > start {
                return Some(next_line[start..end].to_string());
            }
        }
    }
    
    // Try looking a bit further ahead (up to 3 lines) in case of formatting differences
    for offset in 2..=4 {
        if start_index + offset >= lines.len() {
            break;
        }
        
        let check_line = lines[start_index + offset].trim();
        if check_line.starts_with("<string>") && check_line.ends_with("</string>") {
            let start = "<string>".len();
            let end = check_line.len() - "</string>".len();
            if end > start {
                return Some(check_line[start..end].to_string());
            }
        }
    }
    
    None
}
